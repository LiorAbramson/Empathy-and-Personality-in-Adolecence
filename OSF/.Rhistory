y_pred_emo13_6_mat)
colnames(y_pred_emo13_mat)[3] <- "predictedKfold"
y_pred_emo13_mat <- merge(y_pred_emo13_mat,
D13Imp1.1[,c(1:2, which(colnames(D13Imp1.1)=="predicted_emotional_13"))],
all.x=T, all.y=T)
#now check the correlation
cor.test(y_pred_emo13_mat$predictedKfold,y_pred_emo13_mat$predicted_emotional_13)
#relation between predictive scores- cognitive empathy age 13
#organize all the predicted values from the cross-validation analysis into one variable
y_pred_cog13_1_mat <- cbind(D13Imp1.1[D13Imp1.1$gfold==1,1:2], y_pred_cog13_1)
y_pred_cog13_2_mat <- cbind(D13Imp1.1[D13Imp1.1$gfold==2,1:2], y_pred_cog13_2)
y_pred_cog13_3_mat <- cbind(D13Imp1.1[D13Imp1.1$gfold==3,1:2], y_pred_cog13_3)
y_pred_cog13_4_mat <- cbind(D13Imp1.1[D13Imp1.1$gfold==4,1:2], y_pred_cog13_4)
y_pred_cog13_5_mat <- cbind(D13Imp1.1[D13Imp1.1$gfold==5,1:2], y_pred_cog13_5)
y_pred_cog13_6_mat <- cbind(D13Imp1.1[D13Imp1.1$gfold==6,1:2], y_pred_cog13_6)
y_pred_cog13_mat <- rbind(y_pred_cog13_1_mat,
y_pred_cog13_2_mat,
y_pred_cog13_3_mat,
y_pred_cog13_4_mat,
y_pred_cog13_5_mat,
y_pred_cog13_6_mat)
colnames(y_pred_cog13_mat)[3] <- "predictedKfold"
y_pred_cog13_mat <- merge(y_pred_cog13_mat,
D13Imp1.1[,c(1:2, which(colnames(D13Imp1.1)=="predicted_cognitive_13"))],
all.x=T, all.y=T)
#now check the correlation
cor.test(y_pred_cog13_mat$predictedKfold,y_pred_cog13_mat$predicted_cognitive_13)
#changing names to include age
DImp1.1 <- rename(DImp1.1, c(EMPQ_emotional="EMPQ_emotional_11",
EMPQ_cognitive="EMPQ_cognitive_11",
EMPQ_IRI_motiv="EMPQ_IRI_motiv_11"))
D13Imp1.1 <- rename(D13Imp1.1, c(EMPQ_emotional="EMPQ_emotional_13",
EMPQ_cognitive="EMPQ_cognitive_13",
EMPQ_IRI_motiv="EMPQ_IRI_motiv_13"))
#import general unidentified participants details of the Longitudinal Israeli Study of Twins
participants_details <- read.csv ("~/Documents/projects/Empathy-Personality-Adolecence/OSF/data/participants_details.csv")
col <- colnames((participants_details))
relvar_participants_details <- c(which (col=="ifam"), which (col=="ID"),
which (col=="sex"), which (col=="zygosity"),which (col=="zygoAcc3"))
col <- colnames((D))
relvar_more_details_11 <- c(which (col=="ifam"), which (col=="ID"), which (col=="OnlineManual"))
col <- colnames((DImp1.1))
relvar_D11 <-  c(which (col=="ifam"), which (col=="ID"),
which(col=="EMPQ_emotional_11"), which(col=="EMPQ_cognitive_11"),
which(col=="predicted_emotional_11"), which(col=="predicted_cognitive_11"))
col <- colnames((D13))
relvar_more_details_13 <- c(which (col=="ifam"), which (col=="ID"), which (col=="OnlineManual13"))
col <- colnames((D13Imp1.1))
relvar_D13 <-  c(which (col=="ifam"), which (col=="ID"),
which(col=="EMPQ_emotional_13"), which(col=="EMPQ_cognitive_13"),
which(col=="predicted_emotional_13"), which(col=="predicted_cognitive_13"))
#merge final vars from all datasets
Dfinal11 <- merge (D[,relvar_more_details_11],DImp1.1[,relvar_D11], by=c("ifam","ID"), all.y = T)
Dfinal13 <- merge (D13[,relvar_more_details_13],D13Imp1.1[,relvar_D13], by=c("ifam","ID"), all.y = T)
Dfinal_11_13 <- merge(Dfinal11,Dfinal13, by=c("ifam","ID"), all.x=T, all.y=T)
Dfinal_11_13 <- merge(Dfinal_11_13, participants_details[,relvar_participants_details],
by=c("ifam","ID"), all.x=T, all.y=F)
#export to csv
write.csv(Dfinal_11_13,row.names=F,"~/Documents/projects/Empathy-Personality-Adolecence/OSF/data/Dfinal_11_13.csv")
#import data (called panel sample)
DPan <- read.csv ("~/Documents/projects/Empathy-Personality-Adolecence/OSF/data/panel_results_PerEmp.csv")
#reversing items
CreateReverseItems_allData_panel <-function(DPan) {
DPan$BFI6_Rev <- 6-DPan$BFI6
DPan$BFI21_Rev <- 6-DPan$BFI21
DPan$BFI31_Rev <- 6-DPan$BFI31
DPan$BFI2_Rev <- 6-DPan$BFI2
DPan$BFI12_Rev <- 6-DPan$BFI12
DPan$BFI27_Rev <- 6-DPan$BFI27
DPan$BFI37_Rev <- 6-DPan$BFI37
DPan$BFI8_Rev <- 6-DPan$BFI8
DPan$BFI18_Rev <- 6-DPan$BFI18
DPan$BFI23_Rev <- 6-DPan$BFI23
DPan$BFI43_Rev <- 6-DPan$BFI43
DPan$BFI9_Rev <- 6-DPan$BFI9
DPan$BFI24_Rev <- 6-DPan$BFI24
DPan$BFI34_Rev <- 6-DPan$BFI34
DPan$BFI35_Rev <- 6-DPan$BFI35
DPan$BFI41_Rev <- 6-DPan$BFI41
assign ("DPan",DPan,envir = .GlobalEnv)
}
CreateReverseItems_allData_panel (DPan)
#remove children who are too young (elementary school)
DPan <- DPan[DPan$isOut==0,]
col <- colnames(DPan)
relvar_emotional_panel <- c(which (col=="EMPQ_emotional"),
which (col=="BFI1"), which (col=="BFI2_Rev"), which (col=="BFI3"),which (col=="BFI4"),
which (col=="BFI5"),which (col=="BFI6_Rev"),which (col=="BFI7"),which (col=="BFI8_Rev"),
which (col=="BFI9_Rev"),which (col=="BFI10"),which (col=="BFI11"),which (col=="BFI12_Rev"),
which (col=="BFI13"),which (col=="BFI14"),which (col=="BFI15"),which (col=="BFI16"),
which (col=="BFI17"),which (col=="BFI18_Rev"),which (col=="BFI19"),which (col=="BFI20"),
which (col=="BFI21_Rev"),which (col=="BFI22"),which (col=="BFI23_Rev"),which (col=="BFI24_Rev"),
which (col=="BFI25"),which (col=="BFI26"),which (col=="BFI27_Rev"),which (col=="BFI28"),
which (col=="BFI29"),which (col=="BFI30"),which (col=="BFI31_Rev"),which (col=="BFI32"),
which (col=="BFI33"),which (col=="BFI34_Rev"),which (col=="BFI35_Rev"),which (col=="BFI36"),
which (col=="BFI37_Rev"),which (col=="BFI38"),which (col=="BFI39"),which (col=="BFI40"),
which (col=="BFI41_Rev"),which (col=="BFI42"),which (col=="BFI43_Rev"),which (col=="BFI44"))
relvar_cognitive_panel <- c(which(col=="EMPQ_cognitive"),
which (col=="BFI1"), which (col=="BFI2_Rev"), which (col=="BFI3"),which (col=="BFI4"),
which (col=="BFI5"),which (col=="BFI6_Rev"),which (col=="BFI7"),which (col=="BFI8_Rev"),
which (col=="BFI9_Rev"),which (col=="BFI10"),which (col=="BFI11"),which (col=="BFI12_Rev"),
which (col=="BFI13"),which (col=="BFI14"),which (col=="BFI15"),which (col=="BFI16"),
which (col=="BFI17"),which (col=="BFI18_Rev"),which (col=="BFI19"),which (col=="BFI20"),
which (col=="BFI21_Rev"),which (col=="BFI22"),which (col=="BFI23_Rev"),which (col=="BFI24_Rev"),
which (col=="BFI25"),which (col=="BFI26"),which (col=="BFI27_Rev"),which (col=="BFI28"),
which (col=="BFI29"),which (col=="BFI30"),which (col=="BFI31_Rev"),which (col=="BFI32"),
which (col=="BFI33"),which (col=="BFI34_Rev"),which (col=="BFI35_Rev"),which (col=="BFI36"),
which (col=="BFI37_Rev"),which (col=="BFI38"),which (col=="BFI39"),which (col=="BFI40"),
which (col=="BFI41_Rev"),which (col=="BFI42"),which (col=="BFI43_Rev"),which (col=="BFI44"))
#scale all the BFI items so they all will have mean=0 and SD=1
for (i in 2:45) {DPan[,relvar_emotional_panel[i]] <-
scale(DPan[,relvar_emotional_panel[i]], scale=T)}
#check prediction of age 11 model- use the model that was done on the entire sample
#emotional empathy
y_pred_emo_panel <- predict(fit_emo11_all, s=opt_lambda_emo11,
newx = as.matrix(DPan[,relvar_emotional_panel[2:45]]))
cor_panel_emo11<- cor.test(DPan$EMPQ_emotional, y_pred_emo_panel)
R2_panel_emo11 <- as.numeric(cor_panel_emo11$estimate)^2
mse_panel_emo11 <- mean((DPan[,relvar_emotional_panel[1]]-y_pred_emo_panel)^2)
#cognitive empathy
y_pred_cog_panel <- predict(fit_cog11_all, s=opt_lambda_cog11,
newx = as.matrix(DPan[,relvar_cognitive_panel[2:45]]))
cor_panel_cog11 <- cor.test(DPan$EMPQ_cognitive, y_pred_cog_panel)
R2_panel_cog11 <- as.numeric(cor_panel_cog11$estimate)^2
mse_panel_cog11 <- mean((DPan[,relvar_cognitive_panel[1]]-y_pred_cog_panel)^2)
#check the prediction of the age 13 model - use the model that was done on the entire sample
#emotional empathy
y_pred_emo13_panel <- predict(fit_emo13_all, s=opt_lambda_emo13,
newx = as.matrix(DPan[,relvar_emotional_panel[2:45]]))
cor_panel_emo13 <- cor.test(DPan$EMPQ_emotional, y_pred_emo13_panel)
R2_panel_emo13  <- as.numeric(cor_panel_emo13$estimate)^2
mse_panel_emo13 <- mean((DPan[,relvar_emotional_panel[1]]-y_pred_emo13_panel)^2)
#cognitive empathy
y_pred_cog13_panel <- predict(fit_cog13_all, s=opt_lambda_cog13,
newx = as.matrix(DPan[,relvar_cognitive_panel[2:45]]))
cor_panel_cog13 <- cor.test(DPan$EMPQ_cognitive, y_pred_cog13_panel)
R2_panel_cog13  <- as.numeric(cor_panel_cog13$estimate)^2
mse_panel_cog13 <- mean((DPan[,relvar_cognitive_panel[1]]-y_pred_cog13_panel)^2)
#the Ridge function that will be inside the permutation function
#this function is like the original ridge function at the beginning of the script, with two modifications:
#1) DImp is called DImpPerm
#2) instead of extracting all the items' coefficients,
#   it extracts the highest coefficient when the data is scrambled (so it could be compared to the real coefficients)
RidgePermut <- function (DImpPerm,gfold,relvar) {
#find the best lambda-
#use  glmnet default range search by lambda=NULL
#alpha=0 means we use Ridge regression (and not Lasso regression)
#nfolds=10 means that the nested cross-validation procedure for finding the optimal lambda is performed on 10 folds
set.seed(10000)
cv_fit <- cv.glmnet(x=as.matrix(DImpPerm[DImpPerm$gfold != gfold,relvar[2:45]]),
y=DImpPerm[DImpPerm$gfold != gfold,relvar[1]],
alpha=0, lambda=NULL,nfolds=10)
opt_lambda <- cv_fit$lambda.min
opt_lambda_ind <- which(cv_fit$lambda==opt_lambda)
#what are the coefficients when the lambda is optimal
opt_coef <- as.matrix(cv_fit$glmnet.fit$beta[,opt_lambda_ind])
#extract the highest coefficient (in absolute values)
opt_coef_max <- max (abs(opt_coef))
#after finding the best lambda, train the entire train set with that lambda
fit <- glmnet(x=as.matrix(DImpPerm[DImpPerm$gfold != gfold,relvar[2:45]]),
y=DImpPerm[DImpPerm$gfold != gfold,relvar[1]],
alpha = 0, lambda = opt_lambda)
#now check the prediction on the test set
#create the predicted scores according to the model
y_pred <- predict(fit, s=opt_lambda,
newx = as.matrix(DImpPerm[DImpPerm$gfold == gfold,relvar[2:45]]))
mse <- mean((DImpPerm[DImpPerm$gfold == gfold,relvar[1]]-y_pred)^2)
assign ("fit",fit,envir = .GlobalEnv)
assign ("opt_lambda",opt_lambda,envir = .GlobalEnv)
assign ("y_pred",y_pred,envir = .GlobalEnv)
assign ("mse", mse,envir = .GlobalEnv)
assign ("opt_coef_max", opt_coef_max,envir = .GlobalEnv)
}
#the Ridge function that will be inside the permutation function for the age 11&13 analysis
#This function was used only for the overall prediction significance testing but not for the
#individual items' significance testing (which was done for each age separately)
#because of that, it does not extract the maximal coefficient from the permuted (scrambled) analyses
RidgePermut1113 <- function (DImpPerm11,DImpPerm13, gfold,relvar,lambdas) {
#find the best lambda-
#use either glmnet default range search by lambda=NULL or set search by lambda=lambdas
set.seed(10000)
cv_fit <- cv.glmnet(x=as.matrix(DImpPerm11[DImpPerm11$gfold1113 != gfold,relvar[2:45]]),
y=DImpPerm11[DImpPerm11$gfold1113 != gfold,relvar[1]],
alpha=0, lambda=NULL,nfolds=10)
opt_lambda <- cv_fit$lambda.min
opt_lambda_ind <- which(cv_fit$lambda==opt_lambda)
#after finding the best lambda, train the entire train set with that lambda
fit <- glmnet(x=as.matrix(DImpPerm11[DImpPerm11$gfold1113 != gfold,relvar[2:45]]),
y=DImpPerm11[DImpPerm11$gfold1113 != gfold,relvar[1]],
alpha = 0, lambda = opt_lambda)
#now check the prediction on the test set
y_pred <- predict(fit, s=opt_lambda,
newx = as.matrix(DImpPerm13[DImpPerm13$gfold1113 == gfold,relvar[2:45]]))
mse <- mean((DImpPerm13[DImpPerm13$gfold1113 == gfold,relvar[1]]-y_pred)^2)
assign ("fit",fit,envir = .GlobalEnv)
assign ("opt_lambda",opt_lambda,envir = .GlobalEnv)
assign ("y_pred",y_pred,envir = .GlobalEnv)
assign ("mse",mse,envir = .GlobalEnv)
}
#the function for preparing the scrambled data for the permutation process
#the folds (i.e., which family is in each fold) do not change, nor do the variables.
#the only thing that changes, inside the function, is the data (DImp).
#Each time the empathy variable is scrambled, so there is no real relation between
#personality and empathy (because the empathy measure does not really belong to the child)
ScrambleEmpathyVar <- function (DImp,relvar,yname){
#randomize the empathy variable- switch between families but not between individuals to keep
#the dependency between twins
DImpPerm <- DImp[,c(which(colnames(DImp)=="ifam"),which(colnames(DImp)=="ID"),relvar, which (colnames(DImp)=="gfold"))]
#turn to wide format- each family has one row
DImpPermWide <- reshape(DImpPerm, v.names = colnames(DImpPerm[3:(3+length(relvar)-1)]),
timevar = "ID", idvar = "ifam", direction="wide")
DImpPermWide_y <- DImpPermWide[,c(which(colnames(DImpPermWide)=="ifam"),
which(colnames(DImpPermWide)==paste0(yname,".1")),
which(colnames(DImpPermWide)==paste0(yname,".4")))]
#to keep the proportion of missing twins , I scramble separately families with both twins,
#families with just twin A, and  families with just twin B
DImpPermWide_y_both <- na.omit(DImpPermWide_y)
DImpPermWide_y_TA <- DImpPermWide_y[is.na(DImpPermWide_y[,3]),]   #take only families with no twin B
DImpPermWide_y_TB <- DImpPermWide_y[is.na(DImpPermWide_y[,2]),]   #take only families with no twin A
#now scramble the ifam variable so there is no relation between ifam and real empathy score
DImpPermWide_y_both$ifam<- sample(DImpPermWide_y_both$ifam)
DImpPermWide_y_TA$ifam<- sample(DImpPermWide_y_TA$ifam)
DImpPermWide_y_TB$ifam<- sample(DImpPermWide_y_TB$ifam)
DImpPermWide_y <- rbind (DImpPermWide_y_both,DImpPermWide_y_TA,DImpPermWide_y_TB)
#change name of the scrambled empathy variable
colnames(DImpPermWide_y)[2] <- "EMPQ_perm.1"
colnames(DImpPermWide_y)[3] <- "EMPQ_perm.4"
#merge the variables to the file. Now each family recieves the scores of another family
DImpPermWide <- merge (DImpPermWide,DImpPermWide_y,by="ifam", all.x=T, all.y=T)
#turn back to long format (each twin has a row)
DImpPerm <- reshape(DImpPermWide,
varying = colnames(DImpPermWide)[-c(which(colnames(DImpPermWide)=="ifam"),
which(colnames(DImpPermWide)=="gfold"))],
timevar = "ID", idvar = "ifam",direction="long")
DImpPerm <- na.omit(DImpPerm)    #delete missing rows
assign ("DImpPerm", DImpPerm,envir = .GlobalEnv)
}
#the function for preparing the scrambled data for age 13
#the only thing that changed is that the order of the columns was switched.
#this is because in age 13 the first family has only twin B data, which makes Twin B come before twin A.
ScrambleEmpathyVar13 <- function (DImp,relvar,yname){
#randomize the empathy variable- switch between families but not between individuals to keep
#the dependency between twins
DImpPerm <- DImp[,c(1:2,relvar, which (colnames(DImp)=="gfold"))]
DImpPermWide <- reshape(DImpPerm, v.names = colnames(DImpPerm[3:(3+length(relvar)-1)]),
timevar = "ID", idvar = "ifam", direction="wide")
DImpPermWide_y <- DImpPermWide[,c(which(colnames(DImpPermWide)=="ifam"),
which(colnames(DImpPermWide)==paste0(yname,".1")),
which(colnames(DImpPermWide)==paste0(yname,".4")))]
#to keep the proportion of missing twins , I scramble separately families with both twins,
#families with just twin A, and families with just twin B
DImpPermWide_y_both <- na.omit(DImpPermWide_y)
DImpPermWide_y_TA <- DImpPermWide_y[is.na(DImpPermWide_y[,3]),]
DImpPermWide_y_TB <- DImpPermWide_y[is.na(DImpPermWide_y[,2]),]
#now scramble the ifam variable
DImpPermWide_y_both$ifam<- sample(DImpPermWide_y_both$ifam)
DImpPermWide_y_TA$ifam<- sample(DImpPermWide_y_TA$ifam)
DImpPermWide_y_TB$ifam<- sample(DImpPermWide_y_TB$ifam)
DImpPermWide_y <- rbind (DImpPermWide_y_both,DImpPermWide_y_TA,DImpPermWide_y_TB)
#change name of the empathy variable
colnames(DImpPermWide_y)[2] <- "EMPQ_perm.1"
colnames(DImpPermWide_y)[3] <- "EMPQ_perm.4"
##this is what changed from the age 11 function- change the order of the columns so twin B will come first
DImpPermWide_y <- DImpPermWide_y[,c(1,3,2)]
#merge the variables to the file. Now each family receives the scores of another family
DImpPermWide <- merge (DImpPermWide,DImpPermWide_y,by="ifam", all.x=T, all.y=T)
#turn back to long format (each twin has a row)
DImpPerm <- reshape(DImpPermWide,
varying = colnames(DImpPermWide)[-c(which(colnames(DImpPermWide)=="ifam"),
which(colnames(DImpPermWide)=="gfold"))],
timevar = "ID", idvar = "ifam",direction="long")
DImpPerm <- na.omit(DImpPerm)    #delete missing rows
assign ("DImpPerm", DImpPerm,envir = .GlobalEnv)
}
#the function for preparing the age 11 scrambled data for the analysis of age 11 and 13 together
#the only thing that changed from the regular function is that gfold is named gfold1113
ScrambleEmpathyVarBothAges <- function (DImp,relvar,yname){
#randomize the empathy variable- switch between families and not between individuals to keep
#the dependency between twins
DImpPerm <- DImp[,c(1:2,relvar, which (colnames(DImp)=="gfold1113"))]
DImpPermWide <- reshape(DImpPerm, v.names = colnames(DImpPerm[3:(3+length(relvar)-1)]),
timevar = "ID", idvar = "ifam", direction="wide")
DImpPermWide_y <- DImpPermWide[,c(which(colnames(DImpPermWide)=="ifam"),
which(colnames(DImpPermWide)==paste0(yname,".1")),
which(colnames(DImpPermWide)==paste0(yname,".4")))]
#to keep the proportion of missing twins , I scramble separately families with both twins,
#families with just twin A, and  families with just twin B
DImpPermWide_y_both <- na.omit(DImpPermWide_y)
DImpPermWide_y_TA <- DImpPermWide_y[is.na(DImpPermWide_y[,3]),]
DImpPermWide_y_TB <- DImpPermWide_y[is.na(DImpPermWide_y[,2]),]
#now scramble the ifam variable
DImpPermWide_y_both$ifam<- sample(DImpPermWide_y_both$ifam)
DImpPermWide_y_TA$ifam<- sample(DImpPermWide_y_TA$ifam)
DImpPermWide_y_TB$ifam<- sample(DImpPermWide_y_TB$ifam)
DImpPermWide_y <- rbind (DImpPermWide_y_both,DImpPermWide_y_TA,DImpPermWide_y_TB)
#change name of the empathy variable
colnames(DImpPermWide_y)[2] <- "EMPQ_perm.1"
colnames(DImpPermWide_y)[3] <- "EMPQ_perm.4"
#merge the variables to the file. Now each family recieves the scores of another family
DImpPermWide <- merge (DImpPermWide,DImpPermWide_y,by="ifam", all.x=T, all.y=T)
DImpPerm <- reshape(DImpPermWide,
varying = colnames(DImpPermWide)[-c(which(colnames(DImpPermWide)=="ifam"),
which(colnames(DImpPermWide)=="gfold1113"))],
timevar = "ID", idvar = "ifam",direction="long")
DImpPerm <- na.omit(DImpPerm)
assign ("DImpPerm", DImpPerm,envir = .GlobalEnv)
}
# the function for preparing the age 13 scrambled data for the analysis of age 11 and 13 together
# changes from the regular function: gfold is named gfold1113; the order of the columns was switched
# because in age 13 the first family has only twin B data (which makes Twin B come before twin A).
ScrambleEmpathyVarBothAges13 <- function (DImp,relvar,yname){
#randomize the empathy variable- switch between families and not between individuals to keep
#the dependency between twins
DImpPerm <- DImp[,c(1:2,relvar, which (colnames(DImp)=="gfold1113"))]
DImpPermWide <- reshape(DImpPerm, v.names = colnames(DImpPerm[3:(3+length(relvar)-1)]),
timevar = "ID", idvar = "ifam", direction="wide")
DImpPermWide_y <- DImpPermWide[,c(which(colnames(DImpPermWide)=="ifam"),
which(colnames(DImpPermWide)==paste0(yname,".1")),
which(colnames(DImpPermWide)==paste0(yname,".4")))]
#to keep the proportion of missing twins , I scramble separtely families with both twins,
#families with just twin A and families with just twin B
DImpPermWide_y_both <- na.omit(DImpPermWide_y)
DImpPermWide_y_TA <- DImpPermWide_y[is.na(DImpPermWide_y[,3]),]
DImpPermWide_y_TB <- DImpPermWide_y[is.na(DImpPermWide_y[,2]),]
#now scramble the ifam variable
DImpPermWide_y_both$ifam<- sample(DImpPermWide_y_both$ifam)
DImpPermWide_y_TA$ifam<- sample(DImpPermWide_y_TA$ifam)
DImpPermWide_y_TB$ifam<- sample(DImpPermWide_y_TB$ifam)
DImpPermWide_y <- rbind (DImpPermWide_y_both,DImpPermWide_y_TA,DImpPermWide_y_TB)
#change name of the empathy variable
colnames(DImpPermWide_y)[2] <- "EMPQ_perm.1"
colnames(DImpPermWide_y)[3] <- "EMPQ_perm.4"
#change the order of the columns so twin B will come first
DImpPermWide_y <- DImpPermWide_y[,c(1,3,2)]
#merge the variables to the file. Now each family receives the scores of another family
DImpPermWide <- merge (DImpPermWide,DImpPermWide_y,by="ifam", all.x=T, all.y=T)
DImpPerm <- reshape(DImpPermWide,
varying = colnames(DImpPermWide)[-c(which(colnames(DImpPermWide)=="ifam"),
which(colnames(DImpPermWide)=="gfold1113"))],
timevar = "ID", idvar = "ifam",direction="long")
DImpPerm <- na.omit(DImpPerm)
assign ("DImpPerm", DImpPerm,envir = .GlobalEnv)
}
#the permutation function that will be iterated n times:
CrossValRidgePermut <- function (DImp,relvar,yname,RidgePermut,ScrambleEmpathyVar,seed_index) {
#call a new scrambled dataset (DImpPerm)
set.seed(seed_index)                  #each permutation gets a specific random seed in an ascending order
ScrambleEmpathyVar(DImp,relvar,yname)
#defining the new relevant variables set (real personality items, scrambled empathy variable)
col <-colnames(DImpPerm)
relvar_perm <- c(which (col=="EMPQ_perm"),
which (col=="BFI1"), which (col=="BFI2_Rev"), which (col=="BFI3"),which (col=="BFI4"),
which (col=="BFI5"),which (col=="BFI6_Rev"),which (col=="BFI7"),which (col=="BFI8_Rev"),
which (col=="BFI9_Rev"),which (col=="BFI10"),which (col=="BFI11"),which (col=="BFI12_Rev"),
which (col=="BFI13"),which (col=="BFI14"),which (col=="BFI15"),which (col=="BFI16"),
which (col=="BFI17"),which (col=="BFI18_Rev"),which (col=="BFI19"),which (col=="BFI20"),
which (col=="BFI21_Rev"),which (col=="BFI22"),which (col=="BFI23_Rev"),which (col=="BFI24_Rev"),
which (col=="BFI25"),which (col=="BFI26"),which (col=="BFI27_Rev"),which (col=="BFI28"),
which (col=="BFI29"),which (col=="BFI30"),which (col=="BFI31_Rev"),which (col=="BFI32"),
which (col=="BFI33"),which (col=="BFI34_Rev"),which (col=="BFI35_Rev"),which (col=="BFI36"),
which (col=="BFI37_Rev"),which (col=="BFI38"),which (col=="BFI39"),which (col=="BFI40"),
which (col=="BFI41_Rev"),which (col=="BFI42"),which (col=="BFI43_Rev"),which (col=="BFI44"))
#doing Ridge regression on the folds
#fold 1
RidgePermut(DImpPerm=DImpPerm,gfold=1,relvar=relvar_perm)
fit_P_1 <- fit
opt_lambda_P_1 <- opt_lambda
y_pred_P_1 <- y_pred
mse_P_1 <- mse
opt_coef_max_1 <- opt_coef_max
#fold 2
RidgePermut(DImpPerm=DImpPerm,gfold=2,relvar=relvar_perm)
fit_P_2 <- fit
opt_lambda_P_2 <- opt_lambda
y_pred_P_2 <- y_pred
mse_P_2 <- mse
opt_coef_max_2 <- opt_coef_max
#fold 3
RidgePermut(DImpPerm=DImpPerm,gfold=3,relvar=relvar_perm)
fit_P_3 <- fit
opt_lambda_P_3 <- opt_lambda
y_pred_P_3 <- y_pred
mse_P_3 <- mse
opt_coef_max_3 <- opt_coef_max
#fold 4
RidgePermut(DImpPerm=DImpPerm,gfold=4,relvar=relvar_perm)
fit_P_4 <- fit
opt_lambda_P_4 <- opt_lambda
y_pred_P_4 <- y_pred
mse_P_4 <- mse
opt_coef_max_4 <- opt_coef_max
#fold 5
RidgePermut(DImpPerm=DImpPerm,gfold=5,relvar=relvar_perm)
fit_P_5 <- fit
opt_lambda_P_5 <- opt_lambda
y_pred_P_5 <- y_pred
mse_P_5 <- mse
opt_coef_max_5 <- opt_coef_max
#fold 6
RidgePermut(DImpPerm=DImpPerm,gfold=6,relvar=relvar_perm)
fit_P_6 <- fit
opt_lambda_P_6 <- opt_lambda
y_pred_P_6 <- y_pred
mse_P_6 <- mse
opt_coef_max_6 <- opt_coef_max
#finding the mean correlation between outcome and predicted value across the folds
cor_P <-1:6
for (i in 1:6) {
cor_P[i] <- cor.test(DImpPerm$EMPQ_perm[DImpPerm$gfold ==i],
eval(parse(text=paste0("y_pred_P_",i))))[4]}
cor_P <- as.numeric(cor_P)
avecor_Permut <- mean(cor_P)
#computing the mean mse across the folds
mse_P <-1:6
for (i in 1:6) { mse_P[i] <- eval(parse(text=paste0("mse_P_",i)))}
avemse_Permut <- mean(mse_P)
#compute the mean maximal coefficient from all the folds
avemaxcoef_Permut <- mean(c(opt_coef_max_1,opt_coef_max_2,opt_coef_max_3,
opt_coef_max_4,opt_coef_max_5,opt_coef_max_6))
#assign the vector of the average correlation, average mse, and average maximal coefficient
#from all the permutations to the global environment
AveCorMSEPermut <- c(avecor_Permut,avemse_Permut,avemaxcoef_Permut)
seed_index <- seed_index+1    #change the random seed that will enter the next permutation
assign ("seed_index",seed_index,envir = .GlobalEnv)
assign ("AveCorMSEPermut",AveCorMSEPermut,envir = .GlobalEnv)
}
#the permutation function that will be iterated n times- adapted to the analysis of age 11&13 together
CrossValRidgePermut1113 <- function (DImp11,DImp13, relvar,yname11,yname13,
RidgePermut1113, ScrambleEmpathyVar,ScrambleEmpathyVar13,
seed_index){
#call a new scrambled dataset (DImpPerm11)
set.seed(seed_index)             #each permutation gets a specific random seed in an ascending order
ScrambleEmpathyVarBothAges(DImp11,relvar,yname11)
DImpPerm11 <- DImpPerm
#call a new scrambled dataset for age 13(DImpPerm13)
set.seed(seed_index)             #each permutation gets a specific random seed in an ascending order
ScrambleEmpathyVarBothAges13(DImp13,relvar,yname13)
DImpPerm13 <- DImpPerm
#defining the new relevant variables (relvar_perm)
col <-colnames(DImpPerm11)
relvar_perm <- c(which (col=="EMPQ_perm"),
which (col=="BFI1"), which (col=="BFI2_Rev"), which (col=="BFI3"),which (col=="BFI4"),
which (col=="BFI5"),which (col=="BFI6_Rev"),which (col=="BFI7"),which (col=="BFI8_Rev"),
which (col=="BFI9_Rev"),which (col=="BFI10"),which (col=="BFI11"),which (col=="BFI12_Rev"),
which (col=="BFI13"),which (col=="BFI14"),which (col=="BFI15"),which (col=="BFI16"),
which (col=="BFI17"),which (col=="BFI18_Rev"),which (col=="BFI19"),which (col=="BFI20"),
which (col=="BFI21_Rev"),which (col=="BFI22"),which (col=="BFI23_Rev"),which (col=="BFI24_Rev"),
which (col=="BFI25"),which (col=="BFI26"),which (col=="BFI27_Rev"),which (col=="BFI28"),
which (col=="BFI29"),which (col=="BFI30"),which (col=="BFI31_Rev"),which (col=="BFI32"),
which (col=="BFI33"),which (col=="BFI34_Rev"),which (col=="BFI35_Rev"),which (col=="BFI36"),
which (col=="BFI37_Rev"),which (col=="BFI38"),which (col=="BFI39"),which (col=="BFI40"),
which (col=="BFI41_Rev"),which (col=="BFI42"),which (col=="BFI43_Rev"),which (col=="BFI44"))
#doing Ridge regression on the folds
#fold 1
RidgePermut1113(DImpPerm11=DImpPerm11,DImpPerm13=DImpPerm13,
gfold=1,relvar=relvar_perm,lambdas=lambdas)
fit_P_1 <- fit
opt_lambda_P_1 <- opt_lambda
y_pred_P_1 <- y_pred
mse_P_1 <- mse
#fold 2
RidgePermut1113(DImpPerm11=DImpPerm11,DImpPerm13=DImpPerm13,
gfold=2,relvar=relvar_perm,lambdas=lambdas)
fit_P_2 <- fit
opt_lambda_P_2 <- opt_lambda
y_pred_P_2 <- y_pred
mse_P_2 <- mse
#fold 3
RidgePermut1113(DImpPerm11=DImpPerm11,DImpPerm13=DImpPerm13,
gfold=3,relvar=relvar_perm,lambdas=lambdas)
fit_P_3 <- fit
opt_lambda_P_3 <- opt_lambda
y_pred_P_3 <- y_pred
mse_P_3 <- mse
#fold 4
RidgePermut1113(DImpPerm11=DImpPerm11,DImpPerm13=DImpPerm13,
gfold=4,relvar=relvar_perm,lambdas=lambdas)
fit_P_4 <- fit
opt_lambda_P_4 <- opt_lambda
y_pred_P_4 <- y_pred
mse_P_4 <- mse
#fold 5
RidgePermut1113(DImpPerm11=DImpPerm11,DImpPerm13=DImpPerm13,
gfold=5,relvar=relvar_perm,lambdas=lambdas)
fit_P_5 <- fit
opt_lambda_P_5 <- opt_lambda
y_pred_P_5 <- y_pred
mse_P_5 <- mse
#fold 6
RidgePermut1113(DImpPerm11=DImpPerm11,DImpPerm13=DImpPerm13,
gfold=6,relvar=relvar_perm,lambdas=lambdas)
fit_P_6 <- fit
opt_lambda_P_6 <- opt_lambda
y_pred_P_6 <- y_pred
mse_P_6 <- mse
#finding the mean correlation between outcome and predicted value across the folds
cor_P <-1:6
for (i in 1:6) {
cor_P[i] <- cor.test(DImpPerm13$EMPQ_perm[DImpPerm13$gfold1113 ==i],
eval(parse(text=paste0("y_pred_P_",i))))[4]}
cor_P <- as.numeric(cor_P)
avecor_Permut <- mean(cor_P)
#computing the mean mse across the folds
mse_P <-1:6
for (i in 1:6) { mse_P[i] <- eval(parse(text=paste0("mse_P_",i)))}
avemse_Permut <- mean(mse_P)
#take out the average correlation and avverage mse from the function
AveCorMSEPermut <- c(avecor_Permut,avemse_Permut)
seed_index <- seed_index+1        #change the random seed that will enter the next permutation
assign ("seed_index",seed_index,envir = .GlobalEnv)
assign ("AveCorMSEPermut",AveCorMSEPermut,envir = .GlobalEnv)
}
