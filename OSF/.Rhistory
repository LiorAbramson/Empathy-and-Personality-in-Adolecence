which (col=="BFI1"), which (col=="BFI2_Rev"), which (col=="BFI3"),which (col=="BFI4"),
which (col=="BFI5"),which (col=="BFI6_Rev"),which (col=="BFI7"),which (col=="BFI8_Rev"),
which (col=="BFI9_Rev"),which (col=="BFI10"),which (col=="BFI11"),which (col=="BFI12_Rev"),
which (col=="BFI13"),which (col=="BFI14"),which (col=="BFI15"),which (col=="BFI16"),
which (col=="BFI17"),which (col=="BFI18_Rev"),which (col=="BFI19"),which (col=="BFI20"),
which (col=="BFI21_Rev"),which (col=="BFI22"),which (col=="BFI23_Rev"),which (col=="BFI24_Rev"),
which (col=="BFI25"),which (col=="BFI26"),which (col=="BFI27_Rev"),which (col=="BFI28"),
which (col=="BFI29"),which (col=="BFI30"),which (col=="BFI31_Rev"),which (col=="BFI32"),
which (col=="BFI33"),which (col=="BFI34_Rev"),which (col=="BFI35_Rev"),which (col=="BFI36"),
which (col=="BFI37_Rev"),which (col=="BFI38"),which (col=="BFI39"),which (col=="BFI40"),
which (col=="BFI41_Rev"),which (col=="BFI42"),which (col=="BFI43_Rev"),which (col=="BFI44"))
#scale all the BFI items so they all will have mean=0 and SD=1
for (i in 2:45) {DPan[,relvar_emotional_panel[i]] <-
scale(DPan[,relvar_emotional_panel[i]], scale=T)}
#check prediction of age 11 model- use the model that was done on the entire sample
#emotional empathy
y_pred_emo_panel <- predict(fit_emo11_all, s=opt_lambda_emo11,
newx = as.matrix(DPan[,relvar_emotional_panel[2:45]]))
cor_panel_emo11<- cor.test(DPan$EMPQ_emotional, y_pred_emo_panel)
R2_panel_emo11 <- as.numeric(cor_panel_emo11$estimate)^2
mse_panel_emo11 <- mean((DPan[,relvar_emotional_panel[1]]-y_pred_emo_panel)^2)
#cognitive empathy
y_pred_cog_panel <- predict(fit_cog11_all, s=opt_lambda_cog11,
newx = as.matrix(DPan[,relvar_cognitive_panel[2:45]]))
cor_panel_cog11 <- cor.test(DPan$EMPQ_cognitive, y_pred_cog_panel)
R2_panel_cog11 <- as.numeric(cor_panel_cog11$estimate)^2
mse_panel_cog11 <- mean((DPan[,relvar_cognitive_panel[1]]-y_pred_cog_panel)^2)
#check the prediction of the age 13 model - use the model that was done on the entire sample
#emotional empathy
y_pred_emo13_panel <- predict(fit_emo13_all, s=opt_lambda_emo13,
newx = as.matrix(DPan[,relvar_emotional_panel[2:45]]))
cor_panel_emo13 <- cor.test(DPan$EMPQ_emotional, y_pred_emo13_panel)
R2_panel_emo13  <- as.numeric(cor_panel_emo13$estimate)^2
mse_panel_emo13 <- mean((DPan[,relvar_emotional_panel[1]]-y_pred_emo13_panel)^2)
#cognitive empathy
y_pred_cog13_panel <- predict(fit_cog13_all, s=opt_lambda_cog13,
newx = as.matrix(DPan[,relvar_cognitive_panel[2:45]]))
cor_panel_cog13 <- cor.test(DPan$EMPQ_cognitive, y_pred_cog13_panel)
R2_panel_cog13  <- as.numeric(cor_panel_cog13$estimate)^2
mse_panel_cog13 <- mean((DPan[,relvar_cognitive_panel[1]]-y_pred_cog13_panel)^2)
#the Ridge function that will be inside the permutation function
#this function is like the original ridge function at the beginning of the script, with two modifications:
#1) DImp is called DImpPerm
#2) instead of extracting all the items' coefficients,
#   it extracts the highest coefficient when the data is scrambled (so it could be compared to the real coefficients)
RidgePermut <- function (DImpPerm,gfold,relvar) {
#find the best lambda-
#use  glmnet default range search by lambda=NULL
#alpha=0 means we use Ridge regression (and not Lasso regression)
#nfolds=10 means that the nested cross-validation procedure for finding the optimal lambda is performed on 10 folds
set.seed(10000)
cv_fit <- cv.glmnet(x=as.matrix(DImpPerm[DImpPerm$gfold != gfold,relvar[2:45]]),
y=DImpPerm[DImpPerm$gfold != gfold,relvar[1]],
alpha=0, lambda=NULL,nfolds=10)
opt_lambda <- cv_fit$lambda.min
opt_lambda_ind <- which(cv_fit$lambda==opt_lambda)
#what are the coefficients when the lambda is optimal
opt_coef <- as.matrix(cv_fit$glmnet.fit$beta[,opt_lambda_ind])
#extract the highest coefficient (in absolute values)
opt_coef_max <- max (abs(opt_coef))
#after finding the best lambda, train the entire train set with that lambda
fit <- glmnet(x=as.matrix(DImpPerm[DImpPerm$gfold != gfold,relvar[2:45]]),
y=DImpPerm[DImpPerm$gfold != gfold,relvar[1]],
alpha = 0, lambda = opt_lambda)
#now check the prediction on the test set
#create the predicted scores according to the model
y_pred <- predict(fit, s=opt_lambda,
newx = as.matrix(DImpPerm[DImpPerm$gfold == gfold,relvar[2:45]]))
mse <- mean((DImpPerm[DImpPerm$gfold == gfold,relvar[1]]-y_pred)^2)
assign ("fit",fit,envir = .GlobalEnv)
assign ("opt_lambda",opt_lambda,envir = .GlobalEnv)
assign ("y_pred",y_pred,envir = .GlobalEnv)
assign ("mse", mse,envir = .GlobalEnv)
assign ("opt_coef_max", opt_coef_max,envir = .GlobalEnv)
}
#the Ridge function that will be inside the permutation function for the age 11&13 analysis
#This function was used only for the overall prediction significance testing but not for the
#individual items' significance testing (which was done for each age separately)
#because of that, it does not extract the maximal coefficient from the permuted (scrambled) analyses
RidgePermut1113 <- function (DImpPerm11,DImpPerm13, gfold,relvar,lambdas) {
#find the best lambda-
#use either glmnet default range search by lambda=NULL or set search by lambda=lambdas
set.seed(10000)
cv_fit <- cv.glmnet(x=as.matrix(DImpPerm11[DImpPerm11$gfold1113 != gfold,relvar[2:45]]),
y=DImpPerm11[DImpPerm11$gfold1113 != gfold,relvar[1]],
alpha=0, lambda=NULL,nfolds=10)
opt_lambda <- cv_fit$lambda.min
opt_lambda_ind <- which(cv_fit$lambda==opt_lambda)
#after finding the best lambda, train the entire train set with that lambda
fit <- glmnet(x=as.matrix(DImpPerm11[DImpPerm11$gfold1113 != gfold,relvar[2:45]]),
y=DImpPerm11[DImpPerm11$gfold1113 != gfold,relvar[1]],
alpha = 0, lambda = opt_lambda)
#now check the prediction on the test set
y_pred <- predict(fit, s=opt_lambda,
newx = as.matrix(DImpPerm13[DImpPerm13$gfold1113 == gfold,relvar[2:45]]))
mse <- mean((DImpPerm13[DImpPerm13$gfold1113 == gfold,relvar[1]]-y_pred)^2)
assign ("fit",fit,envir = .GlobalEnv)
assign ("opt_lambda",opt_lambda,envir = .GlobalEnv)
assign ("y_pred",y_pred,envir = .GlobalEnv)
assign ("mse",mse,envir = .GlobalEnv)
}
#the function for preparing the scrambled data for the permutation process
#the folds (i.e., which family is in each fold) do not change, nor do the variables.
#the only thing that changes, inside the function, is the data (DImp).
#Each time the empathy variable is scrambled, so there is no real relation between
#personality and empathy (because the empathy measure does not really belong to the child)
ScrambleEmpathyVar <- function (DImp,relvar,yname){
#randomize the empathy variable- switch between families but not between individuals to keep
#the dependency between twins
DImpPerm <- DImp[,c(which(colnames(DImp)=="ifam"),which(colnames(DImp)=="ID"),relvar, which (colnames(DImp)=="gfold"))]
#turn to wide format- each family has one row
DImpPermWide <- reshape(DImpPerm, v.names = colnames(DImpPerm[3:(3+length(relvar)-1)]),
timevar = "ID", idvar = "ifam", direction="wide")
DImpPermWide_y <- DImpPermWide[,c(which(colnames(DImpPermWide)=="ifam"),
which(colnames(DImpPermWide)==paste0(yname,".1")),
which(colnames(DImpPermWide)==paste0(yname,".4")))]
#to keep the proportion of missing twins , I scramble separately families with both twins,
#families with just twin A, and  families with just twin B
DImpPermWide_y_both <- na.omit(DImpPermWide_y)
DImpPermWide_y_TA <- DImpPermWide_y[is.na(DImpPermWide_y[,3]),]   #take only families with no twin B
DImpPermWide_y_TB <- DImpPermWide_y[is.na(DImpPermWide_y[,2]),]   #take only families with no twin A
#now scramble the ifam variable so there is no relation between ifam and real empathy score
DImpPermWide_y_both$ifam<- sample(DImpPermWide_y_both$ifam)
DImpPermWide_y_TA$ifam<- sample(DImpPermWide_y_TA$ifam)
DImpPermWide_y_TB$ifam<- sample(DImpPermWide_y_TB$ifam)
DImpPermWide_y <- rbind (DImpPermWide_y_both,DImpPermWide_y_TA,DImpPermWide_y_TB)
#change name of the scrambled empathy variable
colnames(DImpPermWide_y)[2] <- "EMPQ_perm.1"
colnames(DImpPermWide_y)[3] <- "EMPQ_perm.4"
#merge the variables to the file. Now each family recieves the scores of another family
DImpPermWide <- merge (DImpPermWide,DImpPermWide_y,by="ifam", all.x=T, all.y=T)
#turn back to long format (each twin has a row)
DImpPerm <- reshape(DImpPermWide,
varying = colnames(DImpPermWide)[-c(which(colnames(DImpPermWide)=="ifam"),
which(colnames(DImpPermWide)=="gfold"))],
timevar = "ID", idvar = "ifam",direction="long")
DImpPerm <- na.omit(DImpPerm)    #delete missing rows
assign ("DImpPerm", DImpPerm,envir = .GlobalEnv)
}
#the function for preparing the scrambled data for age 13
#the only thing that changed is that the order of the columns was switched.
#this is because in age 13 the first family has only twin B data, which makes Twin B come before twin A.
ScrambleEmpathyVar13 <- function (DImp,relvar,yname){
#randomize the empathy variable- switch between families but not between individuals to keep
#the dependency between twins
DImpPerm <- DImp[,c(1:2,relvar, which (colnames(DImp)=="gfold"))]
DImpPermWide <- reshape(DImpPerm, v.names = colnames(DImpPerm[3:(3+length(relvar)-1)]),
timevar = "ID", idvar = "ifam", direction="wide")
DImpPermWide_y <- DImpPermWide[,c(which(colnames(DImpPermWide)=="ifam"),
which(colnames(DImpPermWide)==paste0(yname,".1")),
which(colnames(DImpPermWide)==paste0(yname,".4")))]
#to keep the proportion of missing twins , I scramble separately families with both twins,
#families with just twin A, and families with just twin B
DImpPermWide_y_both <- na.omit(DImpPermWide_y)
DImpPermWide_y_TA <- DImpPermWide_y[is.na(DImpPermWide_y[,3]),]
DImpPermWide_y_TB <- DImpPermWide_y[is.na(DImpPermWide_y[,2]),]
#now scramble the ifam variable
DImpPermWide_y_both$ifam<- sample(DImpPermWide_y_both$ifam)
DImpPermWide_y_TA$ifam<- sample(DImpPermWide_y_TA$ifam)
DImpPermWide_y_TB$ifam<- sample(DImpPermWide_y_TB$ifam)
DImpPermWide_y <- rbind (DImpPermWide_y_both,DImpPermWide_y_TA,DImpPermWide_y_TB)
#change name of the empathy variable
colnames(DImpPermWide_y)[2] <- "EMPQ_perm.1"
colnames(DImpPermWide_y)[3] <- "EMPQ_perm.4"
##this is what changed from the age 11 function- change the order of the columns so twin B will come first
DImpPermWide_y <- DImpPermWide_y[,c(1,3,2)]
#merge the variables to the file. Now each family receives the scores of another family
DImpPermWide <- merge (DImpPermWide,DImpPermWide_y,by="ifam", all.x=T, all.y=T)
#turn back to long format (each twin has a row)
DImpPerm <- reshape(DImpPermWide,
varying = colnames(DImpPermWide)[-c(which(colnames(DImpPermWide)=="ifam"),
which(colnames(DImpPermWide)=="gfold"))],
timevar = "ID", idvar = "ifam",direction="long")
DImpPerm <- na.omit(DImpPerm)    #delete missing rows
assign ("DImpPerm", DImpPerm,envir = .GlobalEnv)
}
#the function for preparing the age 11 scrambled data for the analysis of age 11 and 13 together
#the only thing that changed from the regular function is that gfold is named gfold1113
ScrambleEmpathyVarBothAges <- function (DImp,relvar,yname){
#randomize the empathy variable- switch between families and not between individuals to keep
#the dependency between twins
DImpPerm <- DImp[,c(1:2,relvar, which (colnames(DImp)=="gfold1113"))]
DImpPermWide <- reshape(DImpPerm, v.names = colnames(DImpPerm[3:(3+length(relvar)-1)]),
timevar = "ID", idvar = "ifam", direction="wide")
DImpPermWide_y <- DImpPermWide[,c(which(colnames(DImpPermWide)=="ifam"),
which(colnames(DImpPermWide)==paste0(yname,".1")),
which(colnames(DImpPermWide)==paste0(yname,".4")))]
#to keep the proportion of missing twins , I scramble separately families with both twins,
#families with just twin A, and  families with just twin B
DImpPermWide_y_both <- na.omit(DImpPermWide_y)
DImpPermWide_y_TA <- DImpPermWide_y[is.na(DImpPermWide_y[,3]),]
DImpPermWide_y_TB <- DImpPermWide_y[is.na(DImpPermWide_y[,2]),]
#now scramble the ifam variable
DImpPermWide_y_both$ifam<- sample(DImpPermWide_y_both$ifam)
DImpPermWide_y_TA$ifam<- sample(DImpPermWide_y_TA$ifam)
DImpPermWide_y_TB$ifam<- sample(DImpPermWide_y_TB$ifam)
DImpPermWide_y <- rbind (DImpPermWide_y_both,DImpPermWide_y_TA,DImpPermWide_y_TB)
#change name of the empathy variable
colnames(DImpPermWide_y)[2] <- "EMPQ_perm.1"
colnames(DImpPermWide_y)[3] <- "EMPQ_perm.4"
#merge the variables to the file. Now each family recieves the scores of another family
DImpPermWide <- merge (DImpPermWide,DImpPermWide_y,by="ifam", all.x=T, all.y=T)
DImpPerm <- reshape(DImpPermWide,
varying = colnames(DImpPermWide)[-c(which(colnames(DImpPermWide)=="ifam"),
which(colnames(DImpPermWide)=="gfold1113"))],
timevar = "ID", idvar = "ifam",direction="long")
DImpPerm <- na.omit(DImpPerm)
assign ("DImpPerm", DImpPerm,envir = .GlobalEnv)
}
# the function for preparing the age 13 scrambled data for the analysis of age 11 and 13 together
# changes from the regular function: gfold is named gfold1113; the order of the columns was switched
# because in age 13 the first family has only twin B data (which makes Twin B come before twin A).
ScrambleEmpathyVarBothAges13 <- function (DImp,relvar,yname){
#randomize the empathy variable- switch between families and not between individuals to keep
#the dependency between twins
DImpPerm <- DImp[,c(1:2,relvar, which (colnames(DImp)=="gfold1113"))]
DImpPermWide <- reshape(DImpPerm, v.names = colnames(DImpPerm[3:(3+length(relvar)-1)]),
timevar = "ID", idvar = "ifam", direction="wide")
DImpPermWide_y <- DImpPermWide[,c(which(colnames(DImpPermWide)=="ifam"),
which(colnames(DImpPermWide)==paste0(yname,".1")),
which(colnames(DImpPermWide)==paste0(yname,".4")))]
#to keep the proportion of missing twins , I scramble separtely families with both twins,
#families with just twin A and families with just twin B
DImpPermWide_y_both <- na.omit(DImpPermWide_y)
DImpPermWide_y_TA <- DImpPermWide_y[is.na(DImpPermWide_y[,3]),]
DImpPermWide_y_TB <- DImpPermWide_y[is.na(DImpPermWide_y[,2]),]
#now scramble the ifam variable
DImpPermWide_y_both$ifam<- sample(DImpPermWide_y_both$ifam)
DImpPermWide_y_TA$ifam<- sample(DImpPermWide_y_TA$ifam)
DImpPermWide_y_TB$ifam<- sample(DImpPermWide_y_TB$ifam)
DImpPermWide_y <- rbind (DImpPermWide_y_both,DImpPermWide_y_TA,DImpPermWide_y_TB)
#change name of the empathy variable
colnames(DImpPermWide_y)[2] <- "EMPQ_perm.1"
colnames(DImpPermWide_y)[3] <- "EMPQ_perm.4"
#change the order of the columns so twin B will come first
DImpPermWide_y <- DImpPermWide_y[,c(1,3,2)]
#merge the variables to the file. Now each family receives the scores of another family
DImpPermWide <- merge (DImpPermWide,DImpPermWide_y,by="ifam", all.x=T, all.y=T)
DImpPerm <- reshape(DImpPermWide,
varying = colnames(DImpPermWide)[-c(which(colnames(DImpPermWide)=="ifam"),
which(colnames(DImpPermWide)=="gfold1113"))],
timevar = "ID", idvar = "ifam",direction="long")
DImpPerm <- na.omit(DImpPerm)
assign ("DImpPerm", DImpPerm,envir = .GlobalEnv)
}
#the permutation function that will be iterated n times:
CrossValRidgePermut <- function (DImp,relvar,yname,RidgePermut,ScrambleEmpathyVar,seed_index) {
#call a new scrambled dataset (DImpPerm)
set.seed(seed_index)                  #each permutation gets a specific random seed in an ascending order
ScrambleEmpathyVar(DImp,relvar,yname)
#defining the new relevant variables set (real personality items, scrambled empathy variable)
col <-colnames(DImpPerm)
relvar_perm <- c(which (col=="EMPQ_perm"),
which (col=="BFI1"), which (col=="BFI2_Rev"), which (col=="BFI3"),which (col=="BFI4"),
which (col=="BFI5"),which (col=="BFI6_Rev"),which (col=="BFI7"),which (col=="BFI8_Rev"),
which (col=="BFI9_Rev"),which (col=="BFI10"),which (col=="BFI11"),which (col=="BFI12_Rev"),
which (col=="BFI13"),which (col=="BFI14"),which (col=="BFI15"),which (col=="BFI16"),
which (col=="BFI17"),which (col=="BFI18_Rev"),which (col=="BFI19"),which (col=="BFI20"),
which (col=="BFI21_Rev"),which (col=="BFI22"),which (col=="BFI23_Rev"),which (col=="BFI24_Rev"),
which (col=="BFI25"),which (col=="BFI26"),which (col=="BFI27_Rev"),which (col=="BFI28"),
which (col=="BFI29"),which (col=="BFI30"),which (col=="BFI31_Rev"),which (col=="BFI32"),
which (col=="BFI33"),which (col=="BFI34_Rev"),which (col=="BFI35_Rev"),which (col=="BFI36"),
which (col=="BFI37_Rev"),which (col=="BFI38"),which (col=="BFI39"),which (col=="BFI40"),
which (col=="BFI41_Rev"),which (col=="BFI42"),which (col=="BFI43_Rev"),which (col=="BFI44"))
#doing Ridge regression on the folds
#fold 1
RidgePermut(DImpPerm=DImpPerm,gfold=1,relvar=relvar_perm)
fit_P_1 <- fit
opt_lambda_P_1 <- opt_lambda
y_pred_P_1 <- y_pred
mse_P_1 <- mse
opt_coef_max_1 <- opt_coef_max
#fold 2
RidgePermut(DImpPerm=DImpPerm,gfold=2,relvar=relvar_perm)
fit_P_2 <- fit
opt_lambda_P_2 <- opt_lambda
y_pred_P_2 <- y_pred
mse_P_2 <- mse
opt_coef_max_2 <- opt_coef_max
#fold 3
RidgePermut(DImpPerm=DImpPerm,gfold=3,relvar=relvar_perm)
fit_P_3 <- fit
opt_lambda_P_3 <- opt_lambda
y_pred_P_3 <- y_pred
mse_P_3 <- mse
opt_coef_max_3 <- opt_coef_max
#fold 4
RidgePermut(DImpPerm=DImpPerm,gfold=4,relvar=relvar_perm)
fit_P_4 <- fit
opt_lambda_P_4 <- opt_lambda
y_pred_P_4 <- y_pred
mse_P_4 <- mse
opt_coef_max_4 <- opt_coef_max
#fold 5
RidgePermut(DImpPerm=DImpPerm,gfold=5,relvar=relvar_perm)
fit_P_5 <- fit
opt_lambda_P_5 <- opt_lambda
y_pred_P_5 <- y_pred
mse_P_5 <- mse
opt_coef_max_5 <- opt_coef_max
#fold 6
RidgePermut(DImpPerm=DImpPerm,gfold=6,relvar=relvar_perm)
fit_P_6 <- fit
opt_lambda_P_6 <- opt_lambda
y_pred_P_6 <- y_pred
mse_P_6 <- mse
opt_coef_max_6 <- opt_coef_max
#finding the mean correlation between outcome and predicted value across the folds
cor_P <-1:6
for (i in 1:6) {
cor_P[i] <- cor.test(DImpPerm$EMPQ_perm[DImpPerm$gfold ==i],
eval(parse(text=paste0("y_pred_P_",i))))[4]}
cor_P <- as.numeric(cor_P)
avecor_Permut <- mean(cor_P)
#computing the mean mse across the folds
mse_P <-1:6
for (i in 1:6) { mse_P[i] <- eval(parse(text=paste0("mse_P_",i)))}
avemse_Permut <- mean(mse_P)
#compute the mean maximal coefficient from all the folds
avemaxcoef_Permut <- mean(c(opt_coef_max_1,opt_coef_max_2,opt_coef_max_3,
opt_coef_max_4,opt_coef_max_5,opt_coef_max_6))
#assign the vector of the average correlation, average mse, and average maximal coefficient
#from all the permutations to the global environment
AveCorMSEPermut <- c(avecor_Permut,avemse_Permut,avemaxcoef_Permut)
seed_index <- seed_index+1    #change the random seed that will enter the next permutation
assign ("seed_index",seed_index,envir = .GlobalEnv)
assign ("AveCorMSEPermut",AveCorMSEPermut,envir = .GlobalEnv)
}
#the permutation function that will be iterated n times- adapted to the analysis of age 11&13 together
CrossValRidgePermut1113 <- function (DImp11,DImp13, relvar,yname11,yname13,
RidgePermut1113, ScrambleEmpathyVar,ScrambleEmpathyVar13,
seed_index){
#call a new scrambled dataset (DImpPerm11)
set.seed(seed_index)             #each permutation gets a specific random seed in an ascending order
ScrambleEmpathyVarBothAges(DImp11,relvar,yname11)
DImpPerm11 <- DImpPerm
#call a new scrambled dataset for age 13(DImpPerm13)
set.seed(seed_index)             #each permutation gets a specific random seed in an ascending order
ScrambleEmpathyVarBothAges13(DImp13,relvar,yname13)
DImpPerm13 <- DImpPerm
#defining the new relevant variables (relvar_perm)
col <-colnames(DImpPerm11)
relvar_perm <- c(which (col=="EMPQ_perm"),
which (col=="BFI1"), which (col=="BFI2_Rev"), which (col=="BFI3"),which (col=="BFI4"),
which (col=="BFI5"),which (col=="BFI6_Rev"),which (col=="BFI7"),which (col=="BFI8_Rev"),
which (col=="BFI9_Rev"),which (col=="BFI10"),which (col=="BFI11"),which (col=="BFI12_Rev"),
which (col=="BFI13"),which (col=="BFI14"),which (col=="BFI15"),which (col=="BFI16"),
which (col=="BFI17"),which (col=="BFI18_Rev"),which (col=="BFI19"),which (col=="BFI20"),
which (col=="BFI21_Rev"),which (col=="BFI22"),which (col=="BFI23_Rev"),which (col=="BFI24_Rev"),
which (col=="BFI25"),which (col=="BFI26"),which (col=="BFI27_Rev"),which (col=="BFI28"),
which (col=="BFI29"),which (col=="BFI30"),which (col=="BFI31_Rev"),which (col=="BFI32"),
which (col=="BFI33"),which (col=="BFI34_Rev"),which (col=="BFI35_Rev"),which (col=="BFI36"),
which (col=="BFI37_Rev"),which (col=="BFI38"),which (col=="BFI39"),which (col=="BFI40"),
which (col=="BFI41_Rev"),which (col=="BFI42"),which (col=="BFI43_Rev"),which (col=="BFI44"))
#doing Ridge regression on the folds
#fold 1
RidgePermut1113(DImpPerm11=DImpPerm11,DImpPerm13=DImpPerm13,
gfold=1,relvar=relvar_perm,lambdas=lambdas)
fit_P_1 <- fit
opt_lambda_P_1 <- opt_lambda
y_pred_P_1 <- y_pred
mse_P_1 <- mse
#fold 2
RidgePermut1113(DImpPerm11=DImpPerm11,DImpPerm13=DImpPerm13,
gfold=2,relvar=relvar_perm,lambdas=lambdas)
fit_P_2 <- fit
opt_lambda_P_2 <- opt_lambda
y_pred_P_2 <- y_pred
mse_P_2 <- mse
#fold 3
RidgePermut1113(DImpPerm11=DImpPerm11,DImpPerm13=DImpPerm13,
gfold=3,relvar=relvar_perm,lambdas=lambdas)
fit_P_3 <- fit
opt_lambda_P_3 <- opt_lambda
y_pred_P_3 <- y_pred
mse_P_3 <- mse
#fold 4
RidgePermut1113(DImpPerm11=DImpPerm11,DImpPerm13=DImpPerm13,
gfold=4,relvar=relvar_perm,lambdas=lambdas)
fit_P_4 <- fit
opt_lambda_P_4 <- opt_lambda
y_pred_P_4 <- y_pred
mse_P_4 <- mse
#fold 5
RidgePermut1113(DImpPerm11=DImpPerm11,DImpPerm13=DImpPerm13,
gfold=5,relvar=relvar_perm,lambdas=lambdas)
fit_P_5 <- fit
opt_lambda_P_5 <- opt_lambda
y_pred_P_5 <- y_pred
mse_P_5 <- mse
#fold 6
RidgePermut1113(DImpPerm11=DImpPerm11,DImpPerm13=DImpPerm13,
gfold=6,relvar=relvar_perm,lambdas=lambdas)
fit_P_6 <- fit
opt_lambda_P_6 <- opt_lambda
y_pred_P_6 <- y_pred
mse_P_6 <- mse
#finding the mean correlation between outcome and predicted value across the folds
cor_P <-1:6
for (i in 1:6) {
cor_P[i] <- cor.test(DImpPerm13$EMPQ_perm[DImpPerm13$gfold1113 ==i],
eval(parse(text=paste0("y_pred_P_",i))))[4]}
cor_P <- as.numeric(cor_P)
avecor_Permut <- mean(cor_P)
#computing the mean mse across the folds
mse_P <-1:6
for (i in 1:6) { mse_P[i] <- eval(parse(text=paste0("mse_P_",i)))}
avemse_Permut <- mean(mse_P)
#take out the average correlation and avverage mse from the function
AveCorMSEPermut <- c(avecor_Permut,avemse_Permut)
seed_index <- seed_index+1        #change the random seed that will enter the next permutation
assign ("seed_index",seed_index,envir = .GlobalEnv)
assign ("AveCorMSEPermut",AveCorMSEPermut,envir = .GlobalEnv)
}
#run the permuted ridge regression 10000 times
#Emotional empathy-11
seed_index <- 1
PermutVector_emo11 <- replicate(n=10000,
expr=CrossValRidgePermut(
DImp=DImp1.1,relvar=relvar_emotional,
yname="EMPQ_emotional_11",
RidgePermut,ScrambleEmpathyVar,
seed_index=seed_index))
#just for understanding, see the distribution of the permuted scrambled distribution
hist (PermutVector_emo11[1,])          #see the distribution of the correlations
hist (PermutVector_emo11[2,])          #see the distribution of the mse
hist (PermutVector_emo11[3,])          #see the distribution of the maximal item coefficient
#check- what is the proportion of cases in which the real correlation is higher than the
#correlations in that distribution, and what is the proportion of cases in which the real MSE
#is lower than the MSEs in that distribution
realCor_emo11 <- avecor_emo11
proportionCor_emo11 <- sum (realCor_emo11 > PermutVector_emo11[1,] )
realMSE_emo11 <- avemse_emo11
proportionMSE_emo11 <- sum (realMSE_emo11 < PermutVector_emo11[2,] )
#all the correlations in the scrambled analyses are lower than the real correlation.
#similarly, the all the MSEs are higher than the real MSE
#define the real coefficient of each item (in absolute values)
realCoef_emo11 <- abs(opt_coef_emo11_matrix$aveCoef)
#what is the proportion of cases where the real coefficient is higher than the maximal permuted coefficient
proportionCoef_emo11 <- matrix(nrow=1,ncol=44)
for (i in 1:44){
proportionCoef_emo11[i] <- sum (realCoef_emo11[i] > PermutVector_emo11[3,])}
#what coefficients are higher than the maximal value in 99% (p<.01) and 95% (p<.05) of the cases?
proportionCoef_emo11_sig05 <- proportionCoef_emo11 > 9500
proportionCoef_emo11_sig01 <- proportionCoef_emo11 > 9900
#add the significance level to the plot and adjust the graph limits
opt_coef_emo11_matrix$star05 <- ifelse(t(proportionCoef_emo11_sig01)==T,"**",
ifelse (t(proportionCoef_emo11_sig05)==T,"*",""))
plotemo11 + geom_text(data = opt_coef_emo11_matrix,
label = opt_coef_emo11_matrix$star05, nudge_y = 0)+ ylim(-.03, .13)
#Cognitive empathy-11
seed_index <- 1
PermutVector_cog111 <- replicate(n=10000,
expr=CrossValRidgePermut(
DImp=DImp1.1,relvar=relvar_cognitive,
yname="EMPQ_cognitive_11",
RidgePermut,ScrambleEmpathyVar,
seed_index=seed_index))
hist (PermutVector_cog11[1,]) #see the distribution of the correlations
PermutVector_emo11
PermutVector_emo11[3,]
proportionCor_emo11
proportionMSE_emo11
realCoef_emo11
proportionCoef_emo11
View(BFI_labels)
realCor_cog11
#Cognitive empathy-11
seed_index <- 1
PermutVector_cog11 <- replicate(n=10000,
expr=CrossValRidgePermut(
DImp=DImp1.1,relvar=relvar_cognitive,
yname="EMPQ_cognitive_11",
RidgePermut,ScrambleEmpathyVar,
seed_index=seed_index))
hist (PermutVector_cog11[1,]) #see the distribution of the correlations
hist (PermutVector_cog11[2,]) #see the distribution of the mse
hist (PermutVector_cog11[3,]) #see the distribution of the maximal item coefficient
#check- what is the proportion of cases in which the real correlation is higher than the
#correlations in that distribution, and what is the proportion of cases in which the real MSE
#is lower than the MSEs in that distribution
realCor_cog11 <- avecor_cog11
proportionCor_cog11 <- sum (realCor_cog11 > PermutVector_cog11[1,] )
realMSE_cog11 <- avemse_cog11
proportionMSE_cog11 <- sum (realMSE_cog11 < PermutVector_cog11[2,] )
#all the correlations in the scrambled analyses are lower than the real correlation.
#similarly, the all the MSEs are higher than the real MSE
#define the real coefficients of each item (in absolute values)
realCoef_cog11 <- abs(opt_coef_cog11_matrix$aveCoef)
proportionCoef_cog11 <- matrix(nrow=1,ncol=44)
for (i in 1:44){
proportionCoef_cog11[i] <- sum (realCoef_cog11[i] > PermutVector_cog11[3,])}
#what coefficients are higher than the maximal value in 95% of the cases?
proportionCoef_cog11_sig05 <- proportionCoef_cog11 > 9500
proportionCoef_cog11_sig01 <- proportionCoef_cog11 > 9900
#add the significance level to the plots and adjust the graph limits
opt_coef_cog11_matrix$star05 <- ifelse(t(proportionCoef_cog11_sig01)==T,"**",
ifelse (t(proportionCoef_cog11_sig05)==T,"*",""))
plotcog11 + geom_text(data = opt_coef_cog11_matrix,
label = opt_coef_cog11_matrix$star05, nudge_y = 0)+ ylim(-.03, .13)
#Emotional empathy-13
seed_index <- 1
PermutVector_emo13 <- replicate(n=10000,
expr=CrossValRidgePermut(
DImp=D13Imp1.1,relvar=relvar_emotional_13,
yname="EMPQ_emotional_13",
RidgePermut,ScrambleEmpathyVar13,
seed_index=seed_index))
hist (PermutVector_emo13[1,]) #see the distribution of the correlations
PermutVector_emo13
PermutVector_emo13[3,]
PermutVector_cog11[3,1:20] == PermutVector_cog111[3,1:20]
